const std = @import("std");
pub const c = @cImport({
    @cInclude("girepository.h");
});
const emit = @import("helper.zig").emit;

const output_path = "publish/";

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    const cwd = std.fs.cwd();

    const repository: *c.GIRepository = c.g_irepository_get_default();
    var gerror: ?*c.GError = null;
    _ = c.g_irepository_require(repository, "Gtk", null, 0, &gerror);
    if (gerror) |err| {
        std.log.warn("{s}", .{err.message});
        return error.UnexpectedError;
    }
    cwd.makeDir(output_path) catch |err| switch (err) {
        error.PathAlreadyExists => {},
        else => return err,
    };
    var output_dir = try cwd.openDir(output_path, .{});
    defer output_dir.close();
    const namespaces: [*:null]?[*:0]const u8 = c.g_irepository_get_loaded_namespaces(repository);
    for (std.mem.span(namespaces)) |namespaceZ| {
        const namespace = std.mem.span(namespaceZ.?);
        var file_name = try allocator.alloc(u8, namespace.len + ".zig".len);
        defer allocator.free(file_name);
        std.mem.copy(u8, file_name[0..], namespace);
        std.mem.copy(u8, file_name[file_name.len - ".zig".len ..], ".zig");
        const file = try output_dir.createFile(file_name, .{});
        defer file.close();
        const writer = file.writer();
        try writer.print("// This file is generated by gir-zig\n", .{});
        try writer.print("const {s} = @This();\n", .{namespace});
        const dependencies: [*:null]?[*:0]const u8 = c.g_irepository_get_dependencies(repository, namespace.ptr);
        for (std.mem.span(dependencies)) |dependencyZ| {
            const dependency = std.mem.sliceTo(dependencyZ.?, '-');
            // import dependency
            try writer.print("pub const {s} = @import(\"{s}.zig\");\n", .{ dependency, dependency });
            if (std.mem.eql(u8, dependency, "Gtk")) {
                // import 'template' module
                try writer.print("pub const template = @import(\"template.zig\");\n", .{});
            }
        }
        if (std.mem.eql(u8, namespace, "Gtk")) {
            // import 'template' module
            try writer.print("pub const template = @import(\"template.zig\");\n", .{});
        }
        if (std.mem.eql(u8, namespace, "GLib") or std.mem.eql(u8, namespace, "GObject") or std.mem.eql(u8, namespace, "Gio")) {
            // part of 'core' module
            try writer.print("const core = @import(\"core.zig\");\n", .{});
        } else {
            // import 'core' module
            try writer.print("pub const core = @import(\"core.zig\");\n", .{});
        }
        // import 'std'
        try writer.print("const std = @import(\"std\");\n", .{});
        try writer.print("const meta = std.meta;\n", .{});
        try writer.print("const assert = std.debug.assert;\n", .{});
        const n = c.g_irepository_get_n_infos(repository, namespace.ptr);
        for (0..@intCast(n)) |i| {
            const info: *c.GIBaseInfo = c.g_irepository_get_info(repository, namespace.ptr, @intCast(i));
            defer c.g_base_info_unref(info);
            try emit(.{ .info = info }, writer);
        }
    }
}
