#include "gir-zig.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int config_enable_deprecated = 1;
int config_enable_uppercase_constant = 1;
int config_enable_auto_function_comment = 0;
int config_enable_ref_test = 0;
GIRepository *repository = NULL;

// FIXME:
// 1. error: expected type 'core.GType', found 'comptime_int'
//    ret: [*][*:0]core.GType
// 2. error: opaque type 'Pango.Language' cannot be optional
//    pub fn getLanguages(self: Font) ?[*:null]?Pango.Language
// 3. error: expected type '*core.Nullable(Gtk.CellRenderer)', found '*Gtk.CellRenderer'
//    gtk_icon_view_get_cursor(self, &path_mut, &cell_mut)
// 4. error: expected type '*[4]f32', found '*const [4]f32'
//    gtk_snapshot_append_border(self, arg_outline, &arg_border_width, &arg_border_color)
// 5. error: expected type '**[8]Graphene.Vec3', found '*[8]Graphene.Vec3'
//    graphene_box_get_vertices(self, &vertices_mut)
// 6. error: expected type '[4]f32', found '*[4]f32'
//    return ret;
//    note: function return type declared here
//    pub fn getWidths(self: BorderNode) [4]f32
// 7. error: expected type '?GObject.Value', found '*GObject.Value'
//    return if (arg_return_value) |_| return_value_mut else null.*;
//    note: function return type declared here
//    pub fn invoke(self: *Closure, arg_return_value: ?*GObject.Value, arg_param_values: []GObject.Value, arg_invocation_hint: ?*anyopaque) ?GObject.Value
// 8. error: expected type 'core.Nullable(Gio.Cancellable)', found 'Gio.Cancellable'
//    _ = cancelled_fn(self);
// 9. error: expected type '?*GLib.ByteArray', found '**GLib.ByteArray'
//    g_dtls_connection_get_channel_binding_data(self, arg_type, &data_mut, &err);
//
// HarfBuzz.zig:
// error: enum tag value 0 already taken
//    RequiredLigaturesOn = 0,
// note: other occurrence here
//    AllTypeFeaturesOn = 0,

int main(int argc, char *argv[])
{
	repository = g_irepository_get_default();
	GError *error = NULL;
	g_irepository_require(repository, "Gtk", NULL, 0, &error);
	if (error)
	{
		g_error("ERROR: %s\n", error->message);
		return 1;
	}
	char **namespaces = g_irepository_get_loaded_namespaces(repository);
	for (int namespace_idx = 0; namespaces[namespace_idx]; namespace_idx++)
	{
		int len = strlen(namespaces[namespace_idx]);
		char *filename = (char *)malloc((8 + len + 4 + 1) * sizeof(char));
		if (filename == NULL)
		{
			fprintf(stderr, "alloc filename failed\n");
			return 1;
		}
		memcpy(filename, "publish/", 8);
		memcpy(filename + 8, namespaces[namespace_idx], len);
		memcpy(filename + 8 + len, ".zig", 4);
		filename[8 + len + 4] = 0;
		if (freopen(filename, "w", stdout) == NULL)
		{
			fprintf(stderr, "open %s failed\n", filename);
			return 1;
		}
		free(filename);
		printf("// This file was generated by zig-gir-ffi (https://github.com/DerryAlex/zig-gir-ffi/)\n");
		printf("const %s = @This();\n\n", namespaces[namespace_idx]);
		char **dependencies = g_irepository_get_dependencies(repository, namespaces[namespace_idx]);
		for (int i = 0; dependencies[i]; i++)
		{
			char *dependency = strdup(dependencies[i]);
			int sep = 0;
			for (sep = 0; dependency[sep] && dependency[sep] != '-'; sep++);
			dependency[sep] = 0;
			printf("pub const %s = @import(\"%s.zig\");\n", dependency, dependency);
			if (strcmp(dependency, "Gtk") == 0) printf("pub const template = @import(\"template.zig\");\n");
			free(dependency);
		}
		printf("%sconst core = @import(\"core.zig\");\n", (strcmp(namespaces[namespace_idx], "GLib") == 0 || strcmp(namespaces[namespace_idx], "GObject") == 0 || strcmp(namespaces[namespace_idx], "Gio") == 0) ? "" : "pub ");
		if (strcmp(namespaces[namespace_idx], "Gtk") == 0) printf("pub const template = @import(\"template.zig\");\n");
		printf("const std = @import(\"std\");\n");
		printf("const meta = std.meta;\n");
		printf("const assert = std.debug.assert;\n");
		printf("const Allocator = std.mem.Allocator;\n");
		int n = g_irepository_get_n_infos(repository, namespaces[namespace_idx]);
		for (int i = 0; i < n; i++)
		{
			GIBaseInfo *info = g_irepository_get_info(repository, namespaces[namespace_idx], i);
			int is_deprecated = g_base_info_is_deprecated(info);
			if (is_deprecated && !config_enable_deprecated) continue;
			GIInfoType type = g_base_info_get_type(info);
			const char *name = g_base_info_get_name(info);
			switch (type)
			{
				case GI_INFO_TYPE_FUNCTION:
					emit_function(info, name, "", is_deprecated, 0, NULL);
					break;
				case GI_INFO_TYPE_CALLBACK:
					emit_callback(info, name, is_deprecated, 0);
					break;
				case GI_INFO_TYPE_STRUCT:
					emit_struct(info, name, is_deprecated);
					break;
				case GI_INFO_TYPE_BOXED:
					if (GI_IS_STRUCT_INFO(info)) emit_struct(info, name, is_deprecated);
					else emit_union(info, name, is_deprecated);
					break;
				case GI_INFO_TYPE_ENUM:
					emit_enum(info, name, 0, is_deprecated);
					break;
				case GI_INFO_TYPE_FLAGS:
					emit_enum(info, name, 1, is_deprecated);
					break;
				case GI_INFO_TYPE_OBJECT:
					emit_object(info, name, is_deprecated);
					break;
				case GI_INFO_TYPE_INTERFACE:
					emit_interface(info, name, is_deprecated);
					break;
				case GI_INFO_TYPE_CONSTANT:
					emit_constant(info, name, is_deprecated);
					break;
				case GI_INFO_TYPE_UNION:
					emit_union(info, name, is_deprecated);
					break;
				case GI_INFO_TYPE_INVALID:
				case GI_INFO_TYPE_INVALID_0:
				case GI_INFO_TYPE_UNRESOLVED:
				case GI_INFO_TYPE_VALUE:
				case GI_INFO_TYPE_SIGNAL:
				case GI_INFO_TYPE_VFUNC:
				case GI_INFO_TYPE_PROPERTY:
				case GI_INFO_TYPE_FIELD:
				case GI_INFO_TYPE_ARG:
				case GI_INFO_TYPE_TYPE:
				default:
					fprintf(stderr, "Unsupported type %s\n", g_info_type_to_string(type));
					break;
			}
			g_base_info_unref(info);
		}
		if (config_enable_ref_test)
		{
			printf("\n");
			printf("test \"refAllDecls\" {\n");
			printf("    @setEvalBranchQuota(1_000_000);");
			printf("    std.testing.refAllDecls(@This());\n");
			printf("}\n");
		}
		fflush(stdout);
		fclose(stdout);
	}
	return 0;
}
